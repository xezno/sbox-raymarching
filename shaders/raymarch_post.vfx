//================================================================================
// Ray marching post-process demo
// Author: Alex "xezno" Guthrie
// ================================================================================

HEADER
{
    DevShader = true;
    CompileTargets = ( IS_SM_50 && ( PC || VULKAN ) );
    Description = "Basic ray marching";
    Version = 1;
}

MODES
{
    VrForward();
}

FEATURES
{
    // Features MUST begin with F_
}

COMMON
{
    // Required by re_system & re_vr_shared_standard_vs_code
    #include "includes/re_Globals.fxc"
    #include "includes/re_PerViewConstantBuffer.fxc"
    #include "includes/re_PerViewConstantBufferVR.fxc"
    #include "includes/re_SunLightShaderParamsCB.fxc"
    #include "includes/re_system.fxc"

    struct PS_INPUT
    {
        #include "includes/re_vr_shared_standard_ps_input.fxc"
    };

    struct VS_INPUT
    {
        #include "includes/re_vr_shared_standard_vs_input.fxc"
    };
}

VS
{
    #include "includes/re_vr_shared_standard_vs_code.fxc"

    PS_INPUT MainVs(VS_INPUT i)
    {
        // Handle initial calculations for uvs, texture scrolling etc
        PS_INPUT o = VS_SharedStandardProcessing( i );

        o.vPositionPs = float4( i.vPositionOs, 1 ); // We're doing post-processing, so stay with the camera at all times
        return o;
    }
}

PS
{
    RenderState( DepthEnable, false );
    RenderState( DepthWriteEnable, false );

    Texture2D<float4> g_FrameBuffer< AsFramebuffer(true); >;
    SamplerState g_FrameBuffer_s< AddressU(CLAMP); AddressV(CLAMP); AddressW(CLAMP); >;

    float3 SkyColor< UiGroup(""); UiType(Color); >;
    Float3Attribute( SkyColor, true );

    float3 AmbientColor< UiGroup(""); UiType(Color); >;
    Float3Attribute( AmbientColor, true );

    bool DitheringEnabled< UiGroup(""); UiType(CheckBox); Default( 1 ); >;
    BoolAttribute( DitheringEnabled, true );

    int ResolutionDownSampling< UiGroup(""); Default( 1 ); Range( 1, 16 ); >;
    IntAttribute( ResolutionDownSampling, true );

    // Create our output
    struct PS_OUTPUT
    {
        float4 vColor0 : SV_Target0; // Our output color
    };

    // ================================================================================
    // Raymarch includes
    #include "raymarch_common.fxc"
    #include "raymarch_dithering.fxc"
    #include "raymarch_shading.fxc"
    #include "raymarch_materials.fxc"
    #include "raymarch_sdf.fxc"
    #include "raymarch_basic.fxc"
    // ================================================================================
    
    #define GRASS_COLOR float4( 0.416, 0.6, 0.224, 1.0 )

    float GetDist( float3 p, out Material mat ) 
    {
        float d = 1e10;

        mat = MAT_ERROR;

        d = OpU( d, Terrain( p ), MAT_MUD, mat );
        d = OpD( d, -p.z, MAT_GRASS, mat );

        d = OpD( d, Sphere( p - float3( 10.0, 10.0, 3 ), 32 ), MAT_SAND, mat );
        d = OpU( d, Box( p - float3( 10.0, 10.0, 3 ), float3( 3, 3, 1000 ) ), MAT_MATTE_BLACK, mat );

        return d;
    }

    //
    // Main ray marched scene
    //
    float4 RayMarchingPass( PS_INPUT i, float4 inColor ) 
    {
        float2 vSnappedUvs = i.vPositionPs.xy;

        //
        // Camera setup
        //
        float3 cameraPosition = float3( g_vCameraPositionWs.x, g_vCameraPositionWs.y, g_vCameraPositionWs.z ) / 128;
        cameraPosition = cameraPosition + float3( 0, 0, 1 );

        const float fov = 110;
        float Px, Py;
        SetupCamera( vSnappedUvs, fov, Px, Py );

        //
        // Ray march the scene
        //
        Ray ray = CreateRay( float2( Px, Py ), cameraPosition, cameraPosition + float3( 0, 0, 1 ), 1 );
        float3 ro = ray.pos;
        float3 rd = ray.dir;

        float3 resultRd;
        Material mat;
        float d = RayMarch( ro, rd, mat, resultRd );

        // Sun calc
        float sun = clamp( dot( g_vSunLightDir, rd ), 0.0, 1.0 );

        //
        // Lighting / render calculations
        // 
        float3 p = ro + resultRd * d;
        float3 n = GetNormal( p );
        float fLambert = GetLight( p, cameraPosition, n, mat );

        float grassAmt = smoothstep( 0, 1.0, GetNormal( p.xyz ).z * 12 );
        mat.color = lerp( mat.color, GRASS_COLOR, grassAmt );

        inColor = ( mat.color * AmbientColor.xyzx * 1.1 ) + ( mat.color * fLambert * 0.6 );

        // AO
        inColor = lerp( inColor * 0.8, inColor, GetAO( p, n ) );

        // Sun glare
        inColor += ( sun * 0.05 * float4(1,0,0,1) );

        float fogMul = pow( d / MaxDist, 2 );
        fogMul = clamp( fogMul, 0, 1 );

        // Ray didn't hit an object, just draw a basic sky
        float3 fogCol = SkyColor;
        inColor = lerp( inColor, float4( fogCol, 1 ), fogMul );

        inColor.xyz += ( 0.05 * g_vSunLightColor.xyz * pow( sun, 32.0 ) ) * pow( fogMul, 12 );
        inColor.xyz += ( 1.0 * g_vSunLightColor.xyz * pow( sun, 2048.0 ) ) * pow( fogMul, 12 );

        inColor = smoothstep( 0.15, 1.1, inColor );

        return pow( inColor, 0.6 );
    }

    //
    // Post process: dithering
    //
    float4 DitheringPass( PS_INPUT i, float4 inColor ) 
    {
        float2 ScreenResolution = g_vRenderTargetSize / ResolutionDownSampling;
        const float texSize = g_vRenderTargetSize / ScreenResolution;
        // const float snapLevel = 1.0 / 64;

        float4 snappedColor = inColor;
        // snappedColor = round( snappedColor / snapLevel ) * snapLevel;

        float3 samp = Dither( i.vPositionPs.xy / texSize, snappedColor );
        inColor = float4( samp, 1 );
        inColor *= ( luma( samp ) ) * 8;

        inColor = lerp( snappedColor, inColor, 0.025 );

        return inColor;
    }

    PS_OUTPUT MainPs( const PS_INPUT i )
    {
        PS_OUTPUT o;
        o.vColor0 = float4( 0, 0, 0, 0 );

        o.vColor0 = RayMarchingPass( i, o.vColor0 );
        if ( DitheringEnabled )
            o.vColor0 = DitheringPass( i, o.vColor0 );

        o.vColor0 = SrgbGammaToLinear( o.vColor0.xyz ).xyzx;
        return o;
    }
}