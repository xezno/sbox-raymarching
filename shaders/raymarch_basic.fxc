//================================================================================
// Basic ray marching functions
// Author: Alex "xezno" Guthrie
// ================================================================================

#define PI 3.1415925359
#define SURFACE_DIST 0.025
#define EPS 0.005

struct Ray 
{
    float3 pos;
    float3 dir;
};

int MaxSteps< UiGroup(""); UiType( Slider ); Default( 128 ); Range( 1, 4096 ); >;
IntAttribute( MaxSteps, true );

int MaxDist< UiGroup(""); UiType( Slider ); Default( 32 ); Range( 1, 32768 ); UiStep( 128 ); >;
IntAttribute( MaxDist, true );

float GetDist( float3 p, out Material mat ); // Redefine this in your own file!!!

float RayMarch( float3 ro, float3 rd, out Material mat, out float3 resultRd, float stepSizeMul = 1.0f ) 
{
    float dO = 0;

    for (int i = 0; i < MaxSteps; i++)
    { 
        float3 p = (rd * dO) + ro;
        float ds = GetDist( p, mat );
        dO += ds * stepSizeMul;
        rd += float3( 0, 0, 0.0005 * ds );
        if ( dO > MaxDist || ds < SURFACE_DIST )
            break;
    }

    resultRd = rd;
    return dO;
}

float3 GetNormal( float3 p )
{
    Material _;
    float d = GetDist( p, _ );
    float2 e = float2( EPS, 0 );
    float3 n = d - float3(
        GetDist( p - e.xyy, _ ),  
        GetDist( p - e.yxy, _ ),
        GetDist( p - e.yyx, _ )
    );

    return normalize( n );
}

// Specular lighting makes no sense here, but you can enable it below
//#define SPECULAR
float GetLight( float3 p, float3 camPos, float3 n, Material mat )
{ 
    // Lambert shading
    float3 l = g_vSunLightDir;
    float fLambert = ShadeDiffuse( n, l );

#ifdef SPECULAR
    // Specular
    float3 v = normalize( camPos - p );
    float3 h = normalize( l + v );
    fLambert += ShadeSpecular( n, h, mat.specularPow ) * mat.specularAmt;
#endif

    Material _;
    float3 resultRd;
    float d = RayMarch( p + n * SURFACE_DIST * 4, l, _, resultRd ); 
    
    if ( d < length( l ) ) 
        fLambert = -0.5;

    return fLambert;
}

float GetAO( in float3 pos, in float3 nor )
{
    Material _;
    float occ = 0.0;
    float sca = 1.0;
    for( int i = 0; i < 5; i++ )
    {
        float h = 0.01 + 0.12 * float( i ) / 2;
        float d = GetDist( pos + h * nor, _ );
        occ += (h - d) * sca;
        sca *= 0.95;
        if( occ > 0.35 ) break;
    }
    return clamp( 1.0 - 3.0 * occ, 0, 1.0 ) * ( 0.5 + 0.5 * nor.y );
}

Ray CreateRay(float2 uv, float3 camPos, float3 lookAt, float zoom) 
{
    float3 f = g_vCameraDirWs;
    float3 u = g_vCameraUpDirWs;
    float3 r = normalize(cross(f, u));
    float3 c = ( camPos + g_vCameraDirWs ) + f * zoom;
    float3 i = c + uv.x * r + uv.y * u;
    float3 dir = i -camPos;

    Ray ray;
    ray.pos = camPos;
    ray.dir = normalize( dir );
    return ray;
}

void SetupCamera( float2 uvs, float fov, out float Px, out float Py ) 
{
    float2 ScreenResolution = g_vRenderTargetSize / ResolutionDownSampling;
    const float texSize = g_vRenderTargetSize / ScreenResolution;
    float2 snappedUvs = round( uvs / texSize + 0.5 ) * texSize;

    float aspectRatio = g_vRenderTargetSize.x / g_vRenderTargetSize.y;
    Px = (2 * ((snappedUvs.x + 0.5) / g_vRenderTargetSize.x) - 1) * tan( fov / 2 * PI / 180 ) * aspectRatio;
    Py = (2 * ((snappedUvs.y + 0.5) / g_vRenderTargetSize.y) - 1) * tan( fov / 2 * PI / 180 );
    Py = -Py;
}

//
// Operations
//

// Union Operation
float OpU( float a, float b, Material mat, inout Material matO )
{
    float d = min( a, b );
    matO = matO;

    if ( b - d < EPS )
        matO = mat;
    
    return d;
}


// Intersect Operation
float OpI( float a, float b, Material mat, inout Material matO )
{
    float d = max( a, b );
    matO = matO;

    if ( b - d > EPS )
        matO = mat;

    return d;
}

// Diff Operation
float OpD( float a, float b, Material mat, inout Material matO )
{
    float d = max( a, -b );
    matO = matO;
    return d;
}