//================================================================================
// Generic utility functions
// ================================================================================

float3 SrgbGammaToLinear(float3 c) 
{
    c = max(c, 0);
    return c < 0.04045f ? c * 0.0773993805 : pow(c * 0.9478672986 + 0.0521327014, 2.4);
}

Texture2D<float4> g_BlueNoise< Channel( RGBA, "Aniso(AlphaTexture)", Srgb ); AsBlueNoise(true); >;
SamplerState g_BlueNoise_s< Filter(NEAREST); AddressU(MIRROR); AddressV(MIRROR); AddressW(MIRROR); >;
float hash2( float2 n ) 
{
    float2 uv = n * 0.05;
    float4 tx = Tex2DLevel( g_BlueNoise, uv, 2 ).xyzx;
    return tx.x;
}

#define SMOOTH_NOISE_MODE 0
float smoothNoise(float2 uv)
{
#if SMOOTH_NOISE_MODE
    float2 sw = float2(floor(uv.x),floor(uv.y));
    float2 se = float2( ceil(uv.x),floor(uv.y));
    float2 nw = float2(floor(uv.x), ceil(uv.y));
    float2 ne = float2( ceil(uv.x), ceil(uv.y));
    
    float2 interp = smoothstep(0., 1., frac(uv));
    float s = lerp(hash2(sw),hash2(se),interp.x);
    float n = lerp(hash2(nw),hash2(ne),interp.x);
    return lerp(s, n, interp.y);
#else
    float2 id = floor(uv);
    float2 fr = frac(uv);

    fr = fr*fr*(3.0 - 2.0*fr);

    float bl = hash2(id);
    float br = hash2(id + float2(1.0, 0.0));
    float b  = lerp(bl, br, fr.x);

    float tl = hash2(id + float2(0.0, 1.0));
    float tr = hash2(id + float2(1.0, 1.0));
    float t  = lerp(tl, tr, fr.x);

    return lerp(b, t, fr.y);
#endif
}

float TerrainNoise( float2 uv ) 
{
    const int scale = 128;
    float v = 0;
    float2 p;
    float2 u = uv * scale;

    p = u * 1.0;
    v += smoothNoise( p ) * .125;
    p = u * 0.5;
    v += smoothNoise( p ) * .25;
    p = u * 0.05;
    v += smoothNoise( p ) * .5;
    p = u * 0.05;
    v += smoothNoise( p ) * 2;
    p = u * 0.0125;
    v += smoothNoise( p ) * 16;
    p = u * 0.005;
    v += smoothNoise( p ) * 128;

    // Underlying base
    p = u * 0.001;
    v += smoothNoise( p ) * 1024;
    p = u * 0.00025;
    v += smoothNoise( p ) * 2048;

    return v / scale;
}

#define fbmMatrix float3x3( 0.00,  0.80,  0.60, \
                -0.80,  0.36, -0.48, \
                -0.60, -0.48,  0.64)

float fbm( float3 p )
{
    float f;
    f = 0.5f * smoothNoise( p );
    p = mul( fbmMatrix, p ) * 2.02;
    f += 0.25f * smoothNoise( p );
    p = mul( fbmMatrix, p ) * 2.03;
    f += 0.125f * smoothNoise( p );

    return f;
}